<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Account Password Generator</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
.orb { position: fixed; top: 0; left: 0; z-index: -1; border-radius: 50%; background: radial-gradient(circle, rgba(0,255,0,0.28), transparent 70%); box-shadow: 0 0 25px rgba(0,255,0,0.25); opacity: 0; pointer-events: none; mix-blend-mode: screen; will-change: transform, opacity; }
body * { position: relative; z-index: 1; }

  input[type="text"] {
    color: rgb(12, 141, 173);
    background-color: rgb(15,15,15);
    width: 50ch;
    max-width: 100%;
    box-sizing: border-box;
    font-family: monospace;
  }
  select {
    width: auto;
  }
  label { display:block; margin: 8px 0; }
  button { 
    margin-right: 8px;
    color: rgb(52, 112, 240);
    background-color: rgb(42, 41, 43);
    outline-color: rgb(32, 32, 32);
  }
  .note { color: rgb(52,112,240); font-size: 0.9em; margin-top: 20px; }
  .versions-list { font-family: monospace; white-space: pre; background:rgb(15,15,15); padding:20px; border-radius:4px; }

  /* CSS from main.css */
  body {
    background-color: rgb(49, 48, 48);
    color: rgb(52, 112, 240);
    background-image: url("Images/cyberBackground.png");
  }
  h1 {
    color: rgb(12, 141, 173);
  }
</style>

</head>
<body>
  <h1>Account Password Generatorüîê</h1>

  <!-- Master key input (JS var called "Key") -->
  <label>
    Key:
    <input id="masterKey" type="text" autocomplete="off" size="50" />
  </label>

  <label>
    Acc Name:
    <input id="accountName" type="text" autocomplete="off" size="50" />
  </label>

  <label>
    Version:
    <select id="versionSelect"></select>
  </label>

  <div>
    <button id="generateBtn">Generate password</button>
  </div>

  <br />

  <label>
    Generated password:
    <input id="passwordOutput" type="text" readonly />
  </label>

  <div>
    <button id="copyBtn">Copy password</button>
  </div>

  <div class="note">
    <strong>Available versions</strong> (parameters for each version are stored in the code):
    <div id="versionsList" class="versions-list" aria-live="polite"></div>
  </div>

  <script>
    // -------------------------
    // Minimal deterministic password generator
    // - Harden a possibly weak human Key with PBKDF2
    // - Derive per-account bits deterministically
    // - Map bytes to a password using a charset
    // - Versioning included so you can change parameters later without breaking old passwords
    // -------------------------

    const encoder = new TextEncoder();

    // ====== VERSIONS MAP ======
    // Add new versions here. Keep old versions unchanged so old passwords remain reproducible.
    // Each version entry should include:
    //  - kdf: "PBKDF2" (or "Argon2id" if you later add WASM Argon2)
    //  - masterSalt: public salt string (can be changed per version)
    //  - masterIter: iterations for hardening user Key -> master key
    //  - accountIter: iterations for per-account derivation
    //  - hash: hash algorithm for PBKDF2
    //  - charset: allowed characters for final password
    //  - length: desired password length
    //
    // To add a new version:
    // 1) copy an existing entry, change parameters, give it a new key like "v2"
    // 2) update DEFAULT_VERSION below if you want new generation to use the new version by default
    const VERSIONS = {
      "v1": {
        kdf: "PBKDF2",
        masterSalt: "my-app-master-salt-v1",
        masterIter: 250000,
        accountIter: 150000,
        hash: "SHA-256",
        charset: "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*_-+",
        length: 20
      }
      // Example future version:
      // "v2": {
      //   kdf: "Argon2id",
      //   masterSalt: "my-app-master-salt-v2",
      //   masterParams: { mem: 65536, iter: 3, parallelism: 1 },
      //   accountParams: { mem: 65536, iter: 2, parallelism: 1 },
      //   charset: "...",
      //   length: 24
      // }
    };

    // Default encryption ver
    const DEFAULT_VERSION = "v1";
    
    const versionSelect = document.getElementById("versionSelect");
    const versionsListEl = document.getElementById("versionsList");

    function refreshVersionUI() {
      // Clear select
      versionSelect.innerHTML = "";
      const lines = [];
      Object.keys(VERSIONS).forEach(v => {
        const opt = document.createElement("option");
        opt.value = v;
        opt.textContent = v;
        versionSelect.appendChild(opt);

        const p = VERSIONS[v];
        lines.push(`${v}: kdf=${p.kdf}; masterSalt="${p.masterSalt}"; masterIter=${p.masterIter}; accountIter=${p.accountIter}; hash=${p.hash}; len=${p.length}`);
      });
      versionSelect.value = DEFAULT_VERSION in VERSIONS ? DEFAULT_VERSION : Object.keys(VERSIONS)[0];
      versionsListEl.textContent = lines.join("\n");
    }

    refreshVersionUI();

    async function deriveBitsPBKDF2(passwordBytes, saltBytes, iterations, bitLength, hash) {
      const baseKey = await crypto.subtle.importKey(
        "raw",
        passwordBytes,
        { name: "PBKDF2" },
        false,
        ["deriveBits"]
      );

      const bits = await crypto.subtle.deriveBits(
        {
          name: "PBKDF2",
          hash: hash,
          salt: saltBytes,
          iterations: iterations,
        },
        baseKey,
        bitLength
      );

      return new Uint8Array(bits);
    }

    function bytesToPassword(bytes, charset, length) {
      const chars = [];
      const charsetLength = charset.length;

      for (let i = 0; i < length; i++) {
        const b1 = bytes[(i * 2) % bytes.length];
        const b2 = bytes[(i * 2 + 1) % bytes.length];
        const combined = ((b1 << 8) | b2) >>> 0;
        const index = combined % charsetLength;
        chars.push(charset[index]);
      }

      return chars.join("");
    }

    async function generatePassword(Key, accountName, version) {
      if (!Key || !accountName || !version) {
        throw new Error("Key, account name, and version are required.");
      }

      const params = VERSIONS[version];
      if (!params) throw new Error("Unknown version: " + version);

      // 1) Harden the (possibly weak) Key into a strong master key
      // Include version in the master salt so changing version changes outputs predictably
      const masterSaltBytes = encoder.encode(params.masterSalt + "|" + version);
      const masterKeyBytes = await deriveBitsPBKDF2(
        encoder.encode(Key),
        masterSaltBytes,
        params.masterIter,
        256, // bits
        params.hash
      );

      // 2) Derive per-account bits using the hardened master key and a salt that includes version
      const accountSaltBytes = encoder.encode(version + "|" + accountName);
      const accountBits = await deriveBitsPBKDF2(
        masterKeyBytes,
        accountSaltBytes,
        params.accountIter,
        256, // bits
        params.hash
      );

      // 3) Map derived bytes to password characters
      return bytesToPassword(accountBits, params.charset, params.length);
    }

    // Wire up UI
    document.getElementById("generateBtn").addEventListener("click", async () => {
      // Read the master key into the JS variable named "Key"
      const Key = document.getElementById("masterKey").value.trim();
      const accountName = document.getElementById("accountName").value.trim();
      const version = document.getElementById("versionSelect").value;
      const output = document.getElementById("passwordOutput");
      output.value = "";

      try {
        const pwd = await generatePassword(Key, accountName, version);
        output.value = pwd;
      } catch (err) {
        console.error(err);
        alert("Error: " + err.message);
      }
    });

  //Copy button
    document.getElementById("copyBtn").addEventListener("click", async () => {
      const out = document.getElementById("passwordOutput");
      if (!out.value) return;
      try {
        //Use modern clipboard API when available
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(out.value);
        } else {
          out.select();
          document.execCommand("copy");
        }
        //Provide minimal feedback via the button text temporarily
        const btn = document.getElementById("copyBtn");
        const old = btn.textContent;
        btn.textContent = "Copied!";
        setTimeout(() => btn.textContent = old, 1200);
      } catch (e) {
        console.error("Copy failed", e);
        alert("Copy failed");
      }
    });

    // Optional: expose a small helper so you can change DEFAULT_VERSION at runtime in dev console
    // e.g., window.setDefaultVersion("v2")
    window.setDefaultVersion = function(v) {
      if (v in VERSIONS) {
        // Note: this only changes the in-memory default for this page load
        // To change permanently, edit the DEFAULT_VERSION constant in the file.
        versionSelect.value = v;
      } else {
        console.warn("Unknown version:", v);
      }
    };
</script>

<script>
  const MAX_ORBS = 28;
  const orbs = [];
  let lastTime = null;

  function createOrb() {
    const el = document.createElement("div");
    el.className = "orb";

    // Size
    const baseSize = 18 + Math.random() * 32; // 18‚Äì50px
    el.style.width = baseSize + "px";
    el.style.height = baseSize + "px";

    // Spawn from a random edge
    const edge = Math.floor(Math.random() * 4);
    let x, y;

    if (edge === 0) {          // top
      x = Math.random() * window.innerWidth;
      y = -40;
    } else if (edge === 1) {   // bottom
      x = Math.random() * window.innerWidth;
      y = window.innerHeight + 40;
    } else if (edge === 2) {   // left
      x = -40;
      y = Math.random() * window.innerHeight;
    } else {                   // right
      x = window.innerWidth + 40;
      y = Math.random() * window.innerHeight;
    }

    // Movement
    const targetSpeed = 0.02 + Math.random() * 0.05; // final drift speed
    const initialSpeed = targetSpeed * 0.3;          // start slow

    const angle = Math.random() * Math.PI * 2;
    let vx = Math.cos(angle) * initialSpeed;
    let vy = Math.sin(angle) * initialSpeed;

    // Lifespan
    const maxLife = 10000 + Math.random() * 50000; // 10‚Äì60s
    const fadeOutStart = 0.5 + Math.random() * 0.3; // fade at 50‚Äì80%

    // Random direction change timer
    let directionTimer = 1000 + Math.random() * 3000;

    const pulseOffset = Math.random() * Math.PI * 2;

    const orb = {
      el,
      x,
      y,
      vx,
      vy,
      baseSize,
      life: 0,
      maxLife,
      fadeOutStart,
      directionTimer,
      targetSpeed,
      pulseOffset
    };

    document.body.appendChild(el);
    orbs.push(orb);
  }

  function updateOrbs(dt, now) {
    const w = window.innerWidth;
    const h = window.innerHeight;

    for (let i = orbs.length - 1; i >= 0; i--) {
      const o = orbs[i];

      o.life += dt;
      o.directionTimer -= dt;

      // Occasional major direction changes
      if (o.directionTimer <= 0) {
        const angle = Math.random() * Math.PI * 2;
        const newVx = Math.cos(angle) * o.targetSpeed;
        const newVy = Math.sin(angle) * o.targetSpeed;

        // Blend for smooth curves
        const blend = 0.6;
        o.vx = o.vx * (1 - blend) + newVx * blend;
        o.vy = o.vy * (1 - blend) + newVy * blend;

        o.directionTimer = 1000 + Math.random() * 4000;
      }

      // Continuous micro‚Äëdrift noise
      o.vx += (Math.random() - 0.5) * 0.0005 * dt;
      o.vy += (Math.random() - 0.5) * 0.0005 * dt;

      // Smooth acceleration toward target speed
      const speed = Math.sqrt(o.vx * o.vx + o.vy * o.vy);
      if (speed > 0) {
        const accel = 0.00005 * dt;
        const desired = o.targetSpeed;
        o.vx += ((o.vx / speed) * desired - o.vx) * accel;
        o.vy += ((o.vy / speed) * desired - o.vy) * accel;
      }

      // Update position
      o.x += o.vx * dt;
      o.y += o.vy * dt;

      // Remove if too far off-screen or expired
      const margin = 200;
      const offscreen =
        o.x < -margin ||
        o.x > w + margin ||
        o.y < -margin ||
        o.y > h + margin;

      if (offscreen || o.life > o.maxLife) {
        o.el.remove();
        orbs.splice(i, 1);
        continue;
      }

      // Fade in / fade out
      const lifeRatio = o.life / o.maxLife;
      let opacity = Math.min(1, lifeRatio * 2); // fade in

      if (lifeRatio > o.fadeOutStart) {
        const t = (lifeRatio - o.fadeOutStart) / (1 - o.fadeOutStart);
        opacity *= (1 - t); // fade out
      }

      // Pulsing glow
      const pulse = 0.9 + 0.25 * Math.sin(o.pulseOffset + now * 0.0015);

      // Apply transform
      o.el.style.transform = `translate(${o.x}px, ${o.y}px) scale(${pulse})`;
      o.el.style.opacity = opacity.toFixed(3);
    }

    // Maintain population
    while (orbs.length < MAX_ORBS) {
      createOrb();
    }
  }

  function animate(ts) {
    if (lastTime === null) lastTime = ts;
    const dt = ts - lastTime;
    lastTime = ts;

    updateOrbs(dt, ts);
    requestAnimationFrame(animate);
  }

  // Initial spawn
  for (let i = 0; i < MAX_ORBS; i++) {
    createOrb();
  }

  requestAnimationFrame(animate);
</script>
</body>
</html>
